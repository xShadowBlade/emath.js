import Decimal, { DecimalSource, CompareResult } from "./E/e";
declare const E: {
    (x?: DecimalSource): Decimal;
    readonly dZero: Decimal;
    readonly dOne: Decimal;
    readonly dNegOne: Decimal;
    readonly dTwo: Decimal;
    readonly dTen: Decimal;
    readonly dNaN: Decimal;
    readonly dInf: Decimal;
    readonly dNegInf: Decimal;
    readonly dNumberMax: Decimal;
    readonly dNumberMin: Decimal;
    fromComponents(sign: number, layer: number, mag: number): Decimal;
    fromComponents_noNormalize(sign: number, layer: number, mag: number): Decimal;
    fromMantissaExponent(mantissa: number, exponent: number): Decimal;
    fromMantissaExponent_noNormalize(mantissa: number, exponent: number): Decimal;
    fromDecimal(value: Decimal): Decimal;
    fromNumber(value: number): Decimal;
    fromString(value: string): Decimal;
    fromValue(value: DecimalSource): Decimal;
    fromValue_noAlloc(value: DecimalSource): Readonly<Decimal>;
    abs(value: DecimalSource): Decimal;
    neg(value: DecimalSource): Decimal;
    negate(value: DecimalSource): Decimal;
    negated(value: DecimalSource): Decimal;
    sign(value: DecimalSource): number;
    sgn(value: DecimalSource): number;
    round(value: DecimalSource): Decimal;
    floor(value: DecimalSource): Decimal;
    ceil(value: DecimalSource): Decimal;
    trunc(value: DecimalSource): Decimal;
    add(value: DecimalSource, other: DecimalSource): Decimal;
    plus(value: DecimalSource, other: DecimalSource): Decimal;
    sub(value: DecimalSource, other: DecimalSource): Decimal;
    subtract(value: DecimalSource, other: DecimalSource): Decimal;
    minus(value: DecimalSource, other: DecimalSource): Decimal;
    mul(value: DecimalSource, other: DecimalSource): Decimal;
    multiply(value: DecimalSource, other: DecimalSource): Decimal;
    times(value: DecimalSource, other: DecimalSource): Decimal;
    div(value: DecimalSource, other: DecimalSource): Decimal;
    divide(value: DecimalSource, other: DecimalSource): Decimal;
    recip(value: DecimalSource): Decimal;
    reciprocal(value: DecimalSource): Decimal;
    reciprocate(value: DecimalSource): Decimal;
    cmp(value: DecimalSource, other: DecimalSource): CompareResult;
    cmpabs(value: DecimalSource, other: DecimalSource): CompareResult;
    compare(value: DecimalSource, other: DecimalSource): CompareResult;
    isNaN(value: DecimalSource): boolean;
    isFinite(value: DecimalSource): boolean;
    eq(value: DecimalSource, other: DecimalSource): boolean;
    equals(value: DecimalSource, other: DecimalSource): boolean;
    neq(value: DecimalSource, other: DecimalSource): boolean;
    notEquals(value: DecimalSource, other: DecimalSource): boolean;
    lt(value: DecimalSource, other: DecimalSource): boolean;
    lte(value: DecimalSource, other: DecimalSource): boolean;
    gt(value: DecimalSource, other: DecimalSource): boolean;
    gte(value: DecimalSource, other: DecimalSource): boolean;
    max(value: DecimalSource, other: DecimalSource): Decimal;
    min(value: DecimalSource, other: DecimalSource): Decimal;
    minabs(value: DecimalSource, other: DecimalSource): Decimal;
    maxabs(value: DecimalSource, other: DecimalSource): Decimal;
    clamp(value: DecimalSource, min: DecimalSource, max: DecimalSource): Decimal;
    clampMin(value: DecimalSource, min: DecimalSource): Decimal;
    clampMax(value: DecimalSource, max: DecimalSource): Decimal;
    cmp_tolerance(value: DecimalSource, other: DecimalSource, tolerance: number): CompareResult;
    compare_tolerance(value: DecimalSource, other: DecimalSource, tolerance: number): CompareResult;
    eq_tolerance(value: DecimalSource, other: DecimalSource, tolerance: number): boolean;
    equals_tolerance(value: DecimalSource, other: DecimalSource, tolerance: number): boolean;
    neq_tolerance(value: DecimalSource, other: DecimalSource, tolerance: number): boolean;
    notEquals_tolerance(value: DecimalSource, other: DecimalSource, tolerance: number): boolean;
    lt_tolerance(value: DecimalSource, other: DecimalSource, tolerance: number): boolean;
    lte_tolerance(value: DecimalSource, other: DecimalSource, tolerance: number): boolean;
    gt_tolerance(value: DecimalSource, other: DecimalSource, tolerance: number): boolean;
    gte_tolerance(value: DecimalSource, other: DecimalSource, tolerance: number): boolean;
    pLog10(value: DecimalSource): Decimal;
    absLog10(value: DecimalSource): Decimal;
    log10(value: DecimalSource): Decimal;
    log(value: DecimalSource, base: DecimalSource): Decimal;
    log2(value: DecimalSource): Decimal;
    ln(value: DecimalSource): Decimal;
    logarithm(value: DecimalSource, base: DecimalSource): Decimal;
    pow(value: DecimalSource, other: DecimalSource): Decimal;
    pow10(value: DecimalSource): Decimal;
    root(value: DecimalSource, other: DecimalSource): Decimal;
    factorial(value: DecimalSource, _other?: never): Decimal;
    gamma(value: DecimalSource, _other?: never): Decimal;
    lngamma(value: DecimalSource, _other?: never): Decimal;
    exp(value: DecimalSource): Decimal;
    sqr(value: DecimalSource): Decimal;
    sqrt(value: DecimalSource): Decimal;
    cube(value: DecimalSource): Decimal;
    cbrt(value: DecimalSource): Decimal;
    tetrate(value: DecimalSource, height?: number, payload?: DecimalSource): Decimal;
    iteratedexp(value: DecimalSource, height?: number, payload?: Decimal): Decimal;
    iteratedlog(value: DecimalSource, base?: DecimalSource, times?: number): Decimal;
    layeradd10(value: DecimalSource, diff: DecimalSource): Decimal;
    layeradd(value: DecimalSource, diff: number, base?: number): Decimal;
    slog(value: DecimalSource, base?: number): Decimal;
    lambertw(value: DecimalSource): Decimal;
    ssqrt(value: DecimalSource): Decimal;
    pentate(value: DecimalSource, height?: number, payload?: DecimalSource): Decimal;
    affordGeometricSeries(resourcesAvailable: DecimalSource, priceStart: DecimalSource, priceRatio: DecimalSource, currentOwned: DecimalSource): Decimal;
    sumGeometricSeries(numItems: DecimalSource, priceStart: DecimalSource, priceRatio: DecimalSource, currentOwned: DecimalSource): Decimal;
    affordArithmeticSeries(resourcesAvailable: DecimalSource, priceStart: DecimalSource, priceAdd: DecimalSource, currentOwned: DecimalSource): Decimal;
    sumArithmeticSeries(numItems: DecimalSource, priceStart: DecimalSource, priceAdd: DecimalSource, currentOwned: DecimalSource): Decimal;
    efficiencyOfPurchase(cost: DecimalSource, currentRpS: DecimalSource, deltaRpS: DecimalSource): Decimal;
    randomDecimalForTesting(maxLayers: number): Decimal;
    affordGeometricSeries_core(resourcesAvailable: Decimal, priceStart: Decimal, priceRatio: Decimal, currentOwned: DecimalSource): Decimal;
    sumGeometricSeries_core(numItems: DecimalSource, priceStart: Decimal, priceRatio: Decimal, currentOwned: DecimalSource): Decimal;
    affordArithmeticSeries_core(resourcesAvailable: Decimal, priceStart: Decimal, priceAdd: Decimal, currentOwned: Decimal): Decimal;
    sumArithmeticSeries_core(numItems: Decimal, priceStart: Decimal, priceAdd: Decimal, currentOwned: Decimal): Decimal;
    efficiencyOfPurchase_core(cost: Decimal, currentRpS: Decimal, deltaRpS: Decimal): Decimal;
    slog_critical(base: number, height: number): number;
    tetrate_critical(base: number, height: number): number;
    critical_section(base: number, height: number, grid: number[][]): number;
    smoothDamp(current: DecimalSource, target: DecimalSource, smoothing: DecimalSource, deltaTime: DecimalSource): Decimal;
    format(e: DecimalSource, acc?: number, max?: number): string;
};
type E = Decimal;
/**
 * A collection of math-related utility functions and classes.
 */
declare const eMath: {
    getFast: (object: any, id: string) => object | null;
    get: (object: any, id: string) => object | null;
    randomNumber: (min: number, max: number, round?: boolean) => number;
    /**
     * @deprecated dont ever use this
     */
    randomString64: (times: number, type: boolean) => string | number;
    randomString: (length: number) => string;
};
export { eMath, E, DecimalSource as ESource };
